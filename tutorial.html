<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2016-12-07 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20161207" />
    <meta http-equiv="Content-Language" content="en" />
    <title>SDK for CLX XMS &#x2013; Tutorial</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
      <script type="text/javascript" src="./js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarDisabled">
      <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>SDK for CLX XMS</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2016-12-07<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 0.0.1-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Developer Notes</li>
    <li class="active"><a href="#"><span class="none"></span>Tutorial</a>
  </li>
          <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a>  </li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a>  </li>
  </ul>
          <hr />
          <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Tutorial</h1>
<p>The purpose of this document is to present the basic concepts of the CLX Communications HTTP REST Messaging API and how to use it from Java using the HTTP REST Messaging API SDK.</p>
<div class="section">
<h2><a name="HTTP_REST_Messaging_API_basics"></a>HTTP REST Messaging API basics</h2>
<p>HTTP REST Messaging API is a REST API that is provided by CLX Communications for sending and receiving SMS messages. It also provides various other services supporting this task such as managing groups of recipients, tagging, and so forth.</p>
<p>Note, for brevity we will in this document refer to HTTP REST Messaging API as <i>XMS API</i> and the HTTP REST Messaging API service or HTTP endpoint as <i>XMS</i>.</p>
<p>A great benefit of the XMS API is that it allows you to easily create and send <i>batch SMS messages</i>, that is, SMS messages that can have multiple recipients. When creating a batch message it is possible to use <i>message templates</i>, which allows each recipient to receive a personalized message.</p>
<p>To use XMS it is necessary to have a <i>service plan identifier</i> and an <i>authentication token</i>, which can be obtained by creating an XMS service plan.</p>
<p>For full documentation of the XMS API please refer to the <a class="externalLink" href="https://manage.clxcommunications.com/developers/sms/xmsapi.html">REST API documentation site</a>. The documentation site contains up-to-date information about, for example, status and error codes.</p></div>
<div class="section">
<h2><a name="Interacting_with_XMS_through_Java"></a>Interacting with XMS through Java</h2>
<p>Using this Java SDK, all interaction with XMS happens through an <i>API connection</i>, which can be created using the service plan identifier and authentication token. Further configuration can be performed on the API connection but in the typical case a service plan identifier and authentication token is sufficient.</p>
<p>Once an API connection has been established it is possible to send requests to XMS and receive its responses. This is done by calling a suitable method on the API connection, supplying arguments as necessary, and receiving the response either as a return value or through a supplied callback.</p>
<p>This SDK has a focus on asynchronous operation and all interaction with XMS happens asynchronously. Therefore, while synchronous methods are supplied within the library their use is discouraged in most practical applications.</p>
<p>The arguments passed to a connection method are sometimes very simple, fetching a previously create batch simply requires the batch identifier as argument. Other times the arguments are complicated, for example to create the batch it may be necessary to supply a large number of arguments that specify destination addresses, the message body, expiry times, and so on. For such complex arguments we use classes whose methods correspond to the different parameters that are relevant for the request. For each such class we also provide a builder class that lets you create the objects in a convenient manner. The easiest way to access these builders is through the <a href="apidocs/index.html?com/clxcommunications/xms/ClxApi.html"><tt>ClxApi</tt></a> class, which collects all builders that are needed for any of the API calls.</p>
<p>In general the terms used in XMS carry through to the Java API with one major exception. The REST API uses the terms <i>to</i> and <i>from</i> to indicate a message originator and message destination, respectively. In the Java API these are instead denoted <i>recipient</i> and <i>sender</i>. The cause of this name change is to have less confusing and more idiomatic Java method names.</p></div>
<div class="section">
<h2><a name="Connection_management"></a>Connection management</h2>
<p>The first step in using the XMS SDK is to create an API connection object, this object is instantiated from the <a href="apidocs/index.html?com/clxcommunications/xms/ApiConnection.html"><tt>ApiConnection</tt></a> class inside the <a href="apidocs/index.html?com/clxcommunications/xms/package-summary.html"><tt>com.clxcommunications.xms</tt></a> package and it describes everything we need in order to talk with the XMS API endpoint. The minimal amount of information needed are the service plan identifier and the authentication token and, as previously mentioned, these will be provided to you when creating an XMS service.</p>
<p>Assuming we have been given the service plan identifier &#x201c;myplan&#x201d; and authentication token &#x201c;mytoken&#x201d; then an API connection <tt>conn</tt> is created using a builder as follows</p>

<div class="source">
<div class="source"><pre class="prettyprint">ApiConnection conn = ApiConnection.builder()
    .servicePlanId(&quot;myplan&quot;)
    .token(&quot;mytoken&quot;)
    .build();
</pre></div></div>
<p>And we can go on to start the connection &#x2013; which includes creating connection pools and spinning up worker threads &#x2013; by calling the <tt>start</tt> method on the connection:</p>

<div class="source">
<div class="source"><pre class="prettyprint">conn.start()
</pre></div></div>
<p>Since it is very common to instantiate the API connection and immediately starting it we provide a <tt>start</tt> method directly in the builder. In code this appears as follows.</p>

<div class="source">
<div class="source"><pre class="prettyprint">ApiConnection conn = ApiConnection.builder()
    .servicePlanId(&quot;myplan&quot;)
    .token(&quot;mytoken&quot;)
    .start();
</pre></div></div>
<p>Once started the connection can be used to interact with with XMS in the ways described in the following sections of this tutorial.</p>
<p>Note, it is important to close down the API connection when it is no longer needed, typically when your application is shutting down. This is done by calling the <tt>close</tt> method of the connection:</p>

<div class="source">
<div class="source"><pre class="prettyprint">conn.close();
</pre></div></div>
<p>By default the connection will use <tt>https://api.clxcommunications.com/xms</tt> as XMS endpoint. This can be overridden using the <tt>endpoint</tt> method in the API connection builder. For example, the code</p>

<div class="source">
<div class="source"><pre class="prettyprint">ApiConnection conn = ApiConnection.builder()
    .servicePlanId(&quot;myplan&quot;)
    .token(&quot;mytoken&quot;)
    .endpoint(&quot;https://my.test.host:3000/my/base/path&quot;)
    .build();
</pre></div></div>
<p>would make the connection object believe that the <a class="externalLink" href="https://manage.clxcommunications.com/developers/sms/xmsapi.html#batches-endpoint"><tt>batches</tt></a> endpoint is <tt>https://my.test.host:3000/my/base/path/v1/myplan/batches</tt>.</p>
<p>The HTTP client used by the API connection is by default restricted to only connect to HTTPS through TLSv1.2, it is therefore required to use a version of Java that supports this protocol. All versions of Java since <a class="externalLink" href="http://www.oracle.com/technetwork/java/javase/overview-156328.html#R160_121">Java&#xa0;6u121</a> support TLSv1.2.</p></div>
<div class="section">
<h2><a name="Sending_batches"></a>Sending batches</h2>
<p>Creating a batch is typically one of the first things one would like to do when starting to use XMS. To create a batch we must specify, at a minimum, the originating address (typically a short code), one or more recipient addresses (typically MSISDNs), and the message body. To send a simple hello world message to one recipient is then accomplished using</p>

<div class="source">
<div class="source"><pre class="prettyprint">MtBatchTextSmsResult result =
    conn.createBatch(ClxApi.batchTextSms()
        .sender(&quot;12345&quot;)
        .addRecipient(&quot;987654321&quot;)
        .body(&quot;Hello, World!&quot;)
        .build())
</pre></div></div>
<p>You will notice a few things with this code. We are using a <tt>conn</tt> variable that corresponds to an API connection that we assume has been previously created. We are calling the <tt>createBatch</tt> method on the connection with a single argument that describes the batch we wish to create.</p>
<p>Describing the batch is done using an object satisfying the <tt>MtBatchTextSmsCreate</tt> interface. Such objects can most easily be created using the builder returned by <tt>ClxApi.batchTextSms()</tt>. For a batch with a binary body you would similarly describe it using a object satisfying the <tt>MtBatchBinarySmsCreate</tt> interface and typically use <tt>ClxApi.batchBinarySms()</tt> to build such objects.</p>
<p>The return value in this case is a <tt>MtBatchTextSmsResult</tt> object which contains not only the submitted batch information but also information included by XMS, such that the unique batch identifier, the creation time, etc. For example, to simply print the batch identifier we could add the code</p>

<div class="source">
<div class="source"><pre class="prettyprint">System.out.println(&quot;Batch id is &quot; + result.id())
</pre></div></div>
<p>There is also an asynchronous method corresponding to <tt>createBatch</tt> above, called <tt>createBatchAsync</tt>. This method will return immediately with a <tt>Future&lt;MtBatchTextSmsResult&gt;</tt> return value and takes an extra argument that corresponds to a callback that is invoked when the request actually completes. In the asynchronous setting the above example becomes</p>

<div class="source">
<div class="source"><pre class="prettyprint">FutureCallback&lt;MtBatchTextSmsResult&gt; callback = new FutureCallback&lt;MtBatchTextSmsResult&gt; {

    @Override
    public void failed(Exception ex) {
        System.err.println(&quot;Failed to send &quot; + ex.getMessage());
    }

    @Override
    public void completed(BatchDeliveryReport result) {
        System.out.println(&quot;Batch id is &quot; + result.id());
    }

    @Override
    public void cancelled() {
        System.out.println(&quot;Cancelled send&quot;);
    }

};

Future&lt;MtBatchTextSmsResult&gt; future =
    conn.createBatchAsync(ClxApi.batchTextSms()
        .sender(&quot;12345&quot;)
        .addRecipient(&quot;987654321&quot;)
        .body(&quot;Hello, World!&quot;)
        .build(), callback)
</pre></div></div>
<p>The callback that we provided to this method will have one of its methods invoked as soon as the communication with XMS has concluded. Which of the methods that is invoked will depend on how the request went. If all went well then the <tt>completed</tt> method will be called with the result as argument. If some form of exception was thrown during the request then the <tt>failed</tt> method will be called with the exception as argument. For more about error handling see sec. <a href="#Handling_errors">Handling errors</a>. Finally, if the request was canceled, for example using <tt>future.cancel(true)</tt>, then the <tt>cancelled</tt> method is called.</p></div>
<div class="section">
<h2><a name="Listing_batches"></a>Listing batches</h2>
<p>Once you have created a few batches it may be interesting to retrieve a list of all your batches. Retrieving listings of batches is done through a <i>paged result</i>. This means that a single request to XMS may not retrieve all batches. As a result, when calling the <tt>fetchBatches</tt> method on your connection object it will not simply return a list of batches but rather a <a href="apidocs/index.html?com/clxcommunications/xms/PagedFetcher.html"><tt>PagedFetcher</tt></a> object. The paged fetcher in turn can be used to fetch specific pages, iterate over all pages, or directly iterate over all batches while transparently performing necessary page requests.</p>
<p>To limit the number of fetched batches it is also possible to supply a filter that will restrict the fetched batches, for example to those sent after a particular date or having a specific tag or sender.</p>
<p>More specifically, to print the identifier of each batch sent on 2016-12-01 and having the &#x201c;signup-notification&#x201d; tag we may write something like the following.</p>

<div class="source">
<div class="source"><pre class="prettyprint">BatchFilter filter = ClxApi.batchFilter()
    .addTag(&quot;signup-notification&quot;)
    .startDate(LocalDate.of(2016, 12, 1))
    .endDate(LocalDate.of(2016, 12, 2))
    .build();

PagedFetcher&lt;MtBatchSmsResult&gt; fetcher = conn.fetchBatches(filter);

for (MtBatchTextSmsResult batch : fetcher.elements()) {
    System.out.println(&quot;Batch ID: &quot; + batch.id());
}
</pre></div></div></div>
<div class="section">
<h2><a name="Handling_errors"></a>Handling errors</h2>
<p>Any error that occurs during an API operation will result in an exception being thrown. The exceptions produced specifically by the SDK are</p>

<dl>
<dt><a href="apidocs/index.html?com/clxcommunications/xms/ConcurrentException.html"><tt>ConcurrentException</tt></a></dt>
<dd>This exception wraps other checked exceptions that may occur during an XMS request, for example if the XMS server response contains invalid JSON then this exception will be thrown and calling <tt>getCause()</tt> on this exception will return a <tt>JsonParseException</tt> object coming from the <a class="externalLink" href="http://wiki.fasterxml.com/JacksonHome">Jackson</a> JSON library.</dd>
<dt><a href="apidocs/index.html?com/clxcommunications/xms/ErrorResponseException.html"><tt>ErrorResponseException</tt></a></dt>
<dd>If the XMS server responded with a JSON error object containing an error code and error description.</dd>
<dt><a href="apidocs/index.html?com/clxcommunications/xms/UnauthorizedException.html"><tt>UnauthorizedException</tt></a></dt>
<dd>Thrown if an incorrect authentication token was provided for the service plan.</dd>
<dt><a href="apidocs/index.html?com/clxcommunications/xms/UnexpectedResponseException.html"><tt>UnexpectedResponseException</tt></a></dt>
<dd>If the HTTP response from XMS server had an HTTP status that the SDK did not expect and cannot handle, the exception object will contain the complete HTTP response.</dd>
</dl>
<p>each of these exceptions inherit from the base class <a href="apidocs/index.html?com/clxcommunications/xms/ApiException.html"><tt>ApiException</tt></a>.</p></div>
<div class="section">
<h2><a name="Custom_connections"></a>Custom connections</h2>
<p>For most typical use cases the users of the XMS SDK do not have to worry about its internals. However, for some specialized cases the SDK does allow deep access. In particular, if you have special needs concerning the way the SDK does HTTP traffic you can tell the SDK in the API connection to use a Apache HTTP Async Client of your choice. Do note, however, that in such cases the SDK assumes the client is started up and torn down externally to the API connection.</p>
<p>For example, consider a use case where you have two XMS service plans and you wish them to simultaneously interact with XMS from the same application. It may in this case be beneficial to maintain a single connection pool towards XMS for both plans. This requires creating a suitable instance of the <a class="externalLink" href="https://hc.apache.org/httpcomponents-asyncclient-dev/httpasyncclient/apidocs/org/apache/http/nio/client/HttpAsyncClient.html"><tt>HttpAsyncClient</tt></a> class and using it when initializing the API connection. Note, the XMS SDK provides a concrete client class with a suitable configuration for XMS called <a href="apidocs/index.html?com/clxcommunications/xms/ApiHttpAsyncClient.html"><tt>ApiHttpAsyncClient</tt></a>.</p>
<p>Thus, sharing the default HTTP client between two connections may in practice be accomplished with code such at the following.</p>

<div class="source">
<div class="source"><pre class="prettyprint">HttpClient client = ApiHttpAsyncClient.of();
client.start()

ApiConnection conn1 = ApiConnection.builder()
    .httpClient(client)
    .token(token1)
    .servicePlanId(spid1)
    .start();
ApiConnection conn2 = ApiConnection.builder()
    .httpClient(client)
    .token(token2)
    .servicePlanId(spid2)
    .start();

// Interact with conn1 and conn2

conn2.close();
conn1.close();
client.close();
</pre></div></div>
<p>Do note that the <tt>start</tt> and <tt>stop</tt> methods of the <tt>client</tt> variable are called explicitly. This differs from the typical case where starting and stopping the API connection will also start and stop the underlying HTTP connection.</p></div>
<div class="section">
<h2><a name="Glossary"></a>Glossary</h2>

<table border="0" class="table table-striped">
  <thead>
    
<tr class="a">
      
<th>Term </th>
      
<th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td>MSISDN </td>
      
<td>Mobile Subscriber ISDN Number</td>
    </tr>
  </tbody>
</table></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2016
<a href="https://www.clxcommunications.com/">CLX Communications</a>.
All rights reserved.</p>
        </div>
        </div>
    </footer>
    </body>
</html>
