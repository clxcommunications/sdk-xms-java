<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2016-12-05 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20161205" />
    <meta http-equiv="Content-Language" content="en" />
    <title>SDK for CLX XMS &#x2013; Tutorial</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
      <script type="text/javascript" src="./js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarDisabled">
      <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>SDK for CLX XMS</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2016-12-05<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 0.0.1-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Developer Notes</li>
    <li class="active"><a href="#"><span class="none"></span>Tutorial</a>
  </li>
          <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a>  </li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a>  </li>
  </ul>
          <hr />
          <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Tutorial</h1>
<p>The purpose of this document is to present the basic concepts of the CLX Communications HTTP REST Messaging API and how to use it from Java using the HTTP REST Messaging API SDK.</p>
<div class="section">
<h2><a name="HTTP_REST_Messaging_API_basics"></a>HTTP REST Messaging API basics</h2>
<p>HTTP REST Messaging API is a REST API that is provided by CLX Communications for sending and receiving SMS messages. It also provides various other services supporting this task such as managing groups of recipients, tagging, and so forth.</p>
<p>Note, for brevity we will in this document refer to HTTP REST Messaging API as <i>XMS API</i> and the HTTP REST Messaging API service or HTTP endpoint as <i>XMS</i>.</p>
<p>A great benefit of the XMS API is that it allows you to easily create and send <i>batch SMS messages</i>, that is, SMS messages that can have multiple recipients. When creating a batch message it is possible to use <i>message templates</i>, which allows each recipient to receive a personalized message.</p>
<p>To use XMS it is necessary to have a <i>service plan identifier</i> and an <i>authentication token</i>, which can be obtained by creating an XMS service plan.</p>
<p>For full documentation of the XMS API please refer to the <a class="externalLink" href="https://manage.clxcommunications.com/developers/sms/xmsapi.html">REST API documentation site</a>. The documentation site contains up-to-date information about, for example, status and error codes.</p></div>
<div class="section">
<h2><a name="Interacting_with_XMS_through_Java"></a>Interacting with XMS through Java</h2>
<p>Using this Java SDK, all interaction with XMS happens through an <i>API connection</i>, which can be created using the service plan identifier and authentication token. Further configuration can be performed on the API connection but in the typical case a service plan identifier and authentication token is sufficient.</p>
<p>Once an API connection has been established it is possible to send requests to XMS and receive its responses. This is done by calling a suitable method on the API connection, supplying arguments as necessary, and receiving the response either as a return value or through a supplied callback.</p>
<p>This SDK has a focus on asynchronous operation and all interaction with XMS happens asynchronously. Therefore, while synchronous methods are supplied within the library their use is discouraged in most practical applications.</p>
<p>The arguments passed to a connection method are sometimes very simple, fetching a previously create batch simply requires the batch identifier as argument. Other times the arguments are complicated, for example to create the batch it may be necessary to supply a large number of arguments that specify destination addresses, the message body, expiry times, and so on. For such complex arguments we use classes whose methods correspond to the different parameters that are relevant for the request. For each such class we also provide a builder class that lets you create the objects in a convenient manner.</p>
<p>These abstract concepts are made concrete in the text that follows.</p></div>
<div class="section">
<h2><a name="Connection_management"></a>Connection management</h2>
<p>The first step in using the CLX SDK is to create an API connection object, this object is instantiated from the <tt>ApiConnection</tt> class inside the <tt>com.clxcommunications.xms</tt> package and it describes everything we need in order to talk with the XMS API endpoint. The minimal amount of information needed are the service plan identifier and the authentication token and, as previously mentioned, these will be provided to you when creating an XMS service.</p>
<p>Assuming we have been given the service plan identifier &#x201c;myuser&#x201d; and authentication token &#x201c;mytoken&#x201d; then an API connection <tt>conn</tt> is created using a builder as follows</p>

<div class="source">
<div class="source"><pre class="prettyprint">ApiConnection conn = ApiConnection.builder()
    .user(&quot;myuser&quot;)
    .token(&quot;mytoken&quot;)
    .build();
</pre></div></div>
<p>And we can go on to start the connection &#x2013; which includes creating connection pools and spinning up worker threads &#x2013; by calling the <tt>start</tt> method on the connection:</p>

<div class="source">
<div class="source"><pre class="prettyprint">conn.start()
</pre></div></div>
<p>Since it is very common to instantiate the API connection and immediately starting it we provide a <tt>start</tt> method directly in the builder. In code this appears as follows.</p>

<div class="source">
<div class="source"><pre class="prettyprint">ApiConnection conn = ApiConnection.builder()
    .user(&quot;myuser&quot;)
    .token(&quot;mytoken&quot;)
    .start();
</pre></div></div>
<p>Once started the connection can be used to interact with with XMS in the ways described in the following sections of this tutorial.</p>
<p>Note, it is important to close down the API connection when it is no longer needed, typically when your application is shutting down. This is done by calling the <tt>close</tt> method of the connection:</p>

<div class="source">
<div class="source"><pre class="prettyprint">conn.close();
</pre></div></div>
<p>By default the connection will use <tt>https://api.clxcommunications.com/xms</tt> as XMS endpoint. This can be overridden using the <tt>endpoint</tt> method in the API connection builder. For example, the code</p>

<div class="source">
<div class="source"><pre class="prettyprint">ApiConnection conn = ApiConnection.builder()
    .user(&quot;myuser&quot;)
    .token(&quot;mytoken&quot;)
    .endpoint(&quot;https://my.test.host:3000/my/base/path&quot;)
    .build();
</pre></div></div>
<p>would make the connection object believe that the <tt>batches</tt> endpoint is <tt>https://my.test.host:3000/my/base/path/v1/myuser/batches</tt>.</p></div>
<div class="section">
<h2><a name="Sending_batches"></a>Sending batches</h2>
<p>Creating a batch is typically one of the first things one would like to do when starting to use XMS. When creating a batch we specify, at a minimum, the originating address (typically a short code), one or more destination addresses (typically MSISDNs), and the message body. To send a simple hello world message to one recipient then is accomplished using</p>

<div class="source">
<div class="source"><pre class="prettyprint">MtBatchTextSmsResult result =
    conn.createBatch(ClxApi.batchTextSms()
        .from(&quot;12345&quot;)
        .addTo(&quot;987654321&quot;)
        .body(&quot;Hello, World!&quot;)
        .build())
</pre></div></div>
<p>You will notice a few things with this code. We are using a <tt>conn</tt> variable that corresponds to an API connection that we assume has been previously created. We are calling the <tt>createBatch</tt> method on that object with a single argument that describes the batch we wish to create.</p>
<p>Describing the batch is done using an object satisfying the <tt>MtBatchTextSmsCreate</tt> interface. Such objects can most easily be created using the builder returned by <tt>ClxApi.batchTextSms()</tt>. For a batch with a binary body you would similarly describe it using a object satisfying the <tt>MtBatchBinarySmsCreate</tt> interface and typically use <tt>ClxApi.batchBinarySms()</tt> to build such objects.</p>
<p>The return value in this case is a <tt>MtBatchTextSmsResult</tt> object which contains not only the submitted batch information but also information included by XMS, such that the unique batch identifier, the creation time, etc. For example, to simply print the batch identifier we could add the code <tt>java
System.out.println(&quot;Batch id is &quot; + result.id())
</tt></p>
<p>There is also an asynchronous method corresponding to <tt>createBatch</tt> above, called <tt>createBatchAsync</tt>. This method will return immediately with a <tt>Future&lt;MtBatchTextSmsResult&gt;</tt> return value and takes an extra argument that corresponds to a callback that is invoked when the request actually completes. In the asynchronous setting the above example becomes</p>

<div class="source">
<div class="source"><pre class="prettyprint">callback = new FutureCallback&lt;MtBatchTextSmsResult&gt; {

    // Stuff goes here.

};
Future&lt;MtBatchTextSmsResult&gt; future =
    conn.createBatchAsync(ClxApi.batchTextSms()
        .from(&quot;12345&quot;)
        .addTo(&quot;987654321&quot;)
        .body(&quot;Hello, World!&quot;)
        .build(), callback)
</pre></div></div></div>
<div class="section">
<h2><a name="Fetching_batches"></a>Fetching batches</h2></div>
<div class="section">
<h2><a name="Handling_errors"></a>Handling errors</h2></div>
<div class="section">
<h2><a name="Custom_connections"></a>Custom connections</h2>
<p>For most typical use cases the users of the CLX SDK do not have to worry about the internals of the CLX SDK. However, for some specialized cases the SDK does allow deep access. In particular, if you have special needs concerning the way the SDK does HTTP traffic you can tell the SDK in the API connection to use a Apache HTTP Async Client of your choice. Do note, however, that in such cases the SDK assumes the client is started up and torn down externally to the API connection.</p>
<p>For example, consider a use case where you have two XMS users that you wish to simultaneously interact with XMS from the same application. It may in this case be beneficial to maintain a single connection pool towards XMS for both users. In practice this may be accomplished with code such at the following.</p>

<div class="source">
<div class="source"><pre class="prettyprint">HttpClient client = new ApiHttpClient(&#x2026;);
client.start()

ApiConnection conn1 = ApiConnection.builder()
    .httpClient(client)
    .token(token1)
    .user(user1)
    .start();
ApiConnection conn2 = ApiConnection.builder()
    .httpClient(client)
    .token(token2)
    .user(user2)
    .start();

// Interact with conn1 and conn2

conn2.close();
conn1.close();
client.close();
</pre></div></div>
<p>Do note that the <tt>start</tt> and <tt>stop</tt> methods of the <tt>client</tt> variable are called explicitly. This differs from the typical case where starting and stopping the API connection will also start and stop the underlying HTTP connection.</p></div>
<div class="section">
<h2><a name="Glossary"></a>Glossary</h2>

<table border="0" class="table table-striped">
  <thead>
    
<tr class="a">
      
<th>Term </th>
      
<th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td>MSISDN </td>
      
<td>Mobile Subscriber ISDN Number</td>
    </tr>
  </tbody>
</table></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2016
<a href="https://www.clxcommunications.com/">CLX Communications</a>.
All rights reserved.</p>
        </div>
        </div>
    </footer>
    </body>
</html>
